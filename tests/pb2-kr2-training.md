### Частина №1. Монолітна модульна програма

Створити консольну програму, у якій користувач може обрати одну з 2-х дій:

* Вивести у консоль повідомлення `"PRINT!"`
* Вивести у консоль результат додавання 2-х цілих чисел, які він попередньо вводить у консоль

Створити модуль, що містить функції для виконання дій:

```c
// actions.h

void print(void);

int sum(int a, int b);
```

### Частина №2. Клієнт-серверна модульна програма

Розділити клієнтський код, що виконує виклики функції з інтерфейсу модуля та реалізацію модуля 
із частини №1 на дві незалежні програми 
(__Замітка__: Вивід тексту у консоль функцією `print()` відбуватиметься на стороні сервера).

Розділ функціоналу між клієнтом і сервером проходить по викликах функцій модуля. 
Отже, потрібно якимось чином передати інформацію про виклик функції від клієнта до сервера 
та інформацію про результат виклику функції від сервера клієнту.

Для передачі будь-якої інформації між програмами можна використати сокети і один із протоколів транспортного рівня.
При цьому будь-яка інформація буде передана у вигляді послідовності байт. 

Можна описати виклик функцій як структуру типу:

```c
typedef enum { Function_print, Function_sum } Function;

typedef struct {
   Function function;
   int args[2];
} FunctionCall;
```

а результат виклику функції - як структуру такого типу:

```c
typedef struct {
   int returnValue;
} FunctionCallResult;
```

Після цього потрібно описати функції конвертації об'єктів типів 
`FunctionCall` та `FunctionCallResult` у масив байт та навпаки. 
Для цього можна використати такі проміжні перетворення:

```
Struct -> Data Format String -> Bytes
Struct <- Data Format String <- Bytes
```

де в якості `Data Format String` використати один із текстових форматів представлення даних.

Типи `Function`, `FunctionCall` та `FunctionCallResult` і відповідні функції конвертації чудово формують 
новий модуль для віддаленого виклику функції (його можна назвати, наприклад `RemoteFunctions`). 
Але, оскільки цей модуль використовується у двох окремих програмах, то його варто винести
у окрему статичну бібліотеку та підключити до обох проектів

### Частина №3. Завдання зі стеком

Розробити аналогічну клієнт серверну-програму, але у якості модуля використати АТД Стек.
